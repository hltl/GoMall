// Code generated by hertz generator. DO NOT EDIT.

package router

import (
	"context"
	"fmt"
	"strings"
	"github.com/sirupsen/logrus"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/app/server"
	"github.com/hltl/GoMall/api/biz/proto/user"
	"golang.org/x/crypto/bcrypt"

	"gorm.io/gorm"
	"github.com/hltl/GoMall/api/biz/model"
	"github.com/hltl/GoMall/api/biz/proto/auth"
	"runtime/debug"
)

var log = logrus.New()

// UserServer 实现用户服务
type UserServer struct {
	user.UnimplementedUserServiceServer
	// 这里可以注入数据库等依赖
	DB         *gorm.DB          // 导出数据库依赖
	AuthClient auth.AuthServiceClient  // 导出认证服务客户端
}

// Register 用户注册
func (s *UserServer) GeneratedRegister(ctx context.Context, req *user.RegisterReq) (*user.RegisterResp, error) {
	logrus.WithFields(logrus.Fields{
		"operation": "user_registration",
		"email":     req.GetEmail(),
		"client_ip": ctx.Value("client_ip"),
	}).Info("开始处理用户注册请求")

	// 1. 参数校验
	if req.GetPassword() != req.GetConfirmPassword() {
		return nil, status.Error(codes.InvalidArgument, "密码和确认密码不一致")
	}

	// 2. 密码加密
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.GetPassword()), bcrypt.DefaultCost)
    if err != nil {
        return nil, status.Error(codes.Internal, "密码加密失败")
    }

    // 创建用户对象
    newUser := model.User{
        Email:    req.GetEmail(),
        Password: string(hashedPassword),
    }

    // 添加调试日志
    log.Printf("注册请求参数：%+v", req)
    log.Printf("创建用户ID：%d", newUser.ID)
    tx := s.DB.Begin()
    // 修改事务回滚逻辑
    defer func() {
        if r := recover(); r != nil || err != nil {
            tx.Rollback()
        }
    }()

    if err := tx.Create(&newUser).Error; err != nil {
        logrus.WithFields(logrus.Fields{
            "error": err.Error(),
            "user":  newUser,
        }).Error("数据库创建用户失败")
        fmt.Printf("Database error: %v\n", err)
        if strings.Contains(err.Error(), "Duplicate entry") {
            return nil, status.Error(codes.AlreadyExists, "邮箱已注册")
        }
        logrus.WithFields(logrus.Fields{
            "error":     err.Error(),
            "stack":     string(debug.Stack()),
            "request":   req.String(),
        }).Error("用户注册过程中发生异常")
        return nil, status.Error(codes.Internal, "数据库操作失败")
    }
    fmt.Printf("Rows affected: %d\n", tx.RowsAffected)

    // 检查字段类型
    fmt.Printf("User struct type: %T\n", newUser)  // 应为model.User

    // 显式提交事务（修改）
    if err := tx.Commit().Error; err != nil {
        logrus.WithField("error", err).Error("事务提交失败")
        return nil, status.Error(codes.Internal, "事务提交失败")
    }

    // 生成Token（新增）
    tokenResp, err := s.AuthClient.DeliverTokenByRPC(ctx, &auth.DeliverTokenReq{
        UserId: int32(newUser.ID),
    })
    if err != nil {
        logrus.WithError(err).Error("生成Token失败")
        return nil, status.Error(codes.Internal, "令牌生成失败")
    }

    // 添加用户创建成功后的详细日志
    logrus.WithFields(logrus.Fields{
        "user_id":    newUser.ID,
        "email":      newUser.Email,
        "created_at": newUser.CreatedAt,
    }).Info("用户创建成功")

    // 在事务提交后添加日志
    logrus.WithField("user_id", newUser.ID).Info("用户数据已提交到数据库")

    // 在生成Token后添加日志
    logrus.WithFields(logrus.Fields{
        "user_id": newUser.ID,
        "token":   tokenResp.GetToken(),
    }).Debug("Token生成成功")

    return &user.RegisterResp{
        UserId:  int32(newUser.ID),
        Message: "注册成功",
        Token:   tokenResp.GetToken(), // 添加生成的Token
    }, nil
}

func UserHandlerRegister(c context.Context, ctx *app.RequestContext) {
	logrus.WithFields(logrus.Fields{
		"path":   ctx.Path(),
		"method": ctx.Method(),
		"client": ctx.ClientIP(),
	}).Debug("进入注册处理函数")

	// 添加请求体日志
	body := ctx.Request.Body()
	logrus.WithField("request_body", string(body)).Debug("收到请求体")

	var req user.RegisterReq
	if err := ctx.BindAndValidate(&req); err != nil {
		logrus.WithFields(logrus.Fields{
			"error":  err.Error(),
			"params": ctx.Request.PostArgs().String(),
		}).Warn("参数验证失败")
		ctx.JSON(400, map[string]string{"error": "参数错误: " + err.Error()})
		return
	}

	// 验证必要字段
	if req.Email == "" || req.Password == "" || req.ConfirmPassword == "" {
		logrus.Warn("缺少必要字段")
		ctx.JSON(400, map[string]string{"error": "邮箱、密码和确认密码都是必填项"})
		return
	}

	// 从Hertz上下文获取服务实例
	srv, ok := ctx.Get("userService")
	if !ok {
		logrus.Error("服务实例获取失败，中间件未正确注入")
		ctx.JSON(500, map[string]string{"error": "服务初始化错误"})
		return
	}

	userSrv, ok := srv.(*UserServer)
	if !ok {
		logrus.Error("服务实例类型错误")
		ctx.JSON(500, map[string]string{"error": "服务类型错误"})
		return
	}
	
	// 调用方法时使用srv实例
	resp, err := userSrv.GeneratedRegister(c, &req)
	if err != nil {
		logrus.WithError(err).Error("注册失败")
		ctx.JSON(500, map[string]string{"error": err.Error()})
		return
	}
	
	// 添加响应验证方法
	if err := validateRegisterResponse(resp); err != nil {
		logrus.WithError(err).Error("响应数据异常")
		ctx.JSON(500, map[string]string{"error": "响应数据异常"})
		return
	}
	
	logrus.WithFields(logrus.Fields{
		"user_id": resp.UserId,
		"email":   req.Email,
	}).Info("用户注册成功")

	ctx.JSON(200, map[string]interface{}{
		"code":    0,
		"user_id": resp.UserId,
		"message": resp.Message,
		"token":   resp.Token,
	})
}

// Login 用户登录
func (s *UserServer) Login(ctx context.Context, req *user.LoginReq) (*user.LoginResp, error) {
	// 查询用户
    var dbUser model.User
    if err := s.DB.Where("email = ?", req.GetEmail()).First(&dbUser).Error; err != nil {
        if err == gorm.ErrRecordNotFound {
            return nil, status.Error(codes.NotFound, "用户不存在")
        }
        return nil, status.Error(codes.Internal, "数据库查询失败")
    }

    // 验证密码
    if err := bcrypt.CompareHashAndPassword([]byte(dbUser.Password), []byte(req.GetPassword())); err != nil {
        return nil, status.Error(codes.Unauthenticated, "密码错误")
    }

    // 调用认证服务生成Token（新增）
    tokenResp, err := s.AuthClient.DeliverTokenByRPC(ctx, &auth.DeliverTokenReq{
        UserId: int32(dbUser.ID),
    })
    if err != nil {
        return nil, status.Error(codes.Internal, "令牌生成失败: "+err.Error())
    }

    // 返回响应（可返回token）
    return &user.LoginResp{
        UserId: int32(dbUser.ID),
        Token:  tokenResp.GetToken(), // 需要proto添加token字段
    }, nil
}

func Register(r *server.Hertz) {
	r.POST("/register", func(c context.Context, ctx *app.RequestContext) {
		// 注册处理逻辑
	})
}

// 登录处理函数
func UserHandlerLogin(c context.Context, ctx *app.RequestContext) {
	// 从上下文获取服务实例
	srv, ok := ctx.Get("userService")
	if !ok {
		logrus.Error("服务实例获取失败，中间件未正确注入")
		ctx.JSON(500, map[string]string{"error": "服务初始化错误"})
		return
	}

	userSrv, ok := srv.(*UserServer)
	if !ok {
		logrus.Error("服务实例类型错误")
		ctx.JSON(500, map[string]string{"error": "服务类型错误"})
		return
	}

	// 绑定请求参数
	var req user.LoginReq
	if err := ctx.BindAndValidate(&req); err != nil {
		logrus.WithError(err).Warn("登录参数验证失败")
		ctx.JSON(400, map[string]string{"error": "参数错误: " + err.Error()})
		return
	}

	// 添加参数验证
	if req.Email == "" || req.Password == "" {
		logrus.Warn("登录缺少必要字段")
		ctx.JSON(400, map[string]string{"error": "邮箱和密码都是必填项"})
		return
	}

	// 调用登录方法
	resp, err := userSrv.Login(c, &req)
	if err != nil {
		logrus.WithError(err).Error("登录失败")
		ctx.JSON(500, map[string]string{"error": err.Error()})
		return
	}

	logrus.WithFields(logrus.Fields{
		"user_id": resp.UserId,
		"email":   req.Email,
	}).Info("用户登录成功")

	ctx.JSON(200, map[string]interface{}{
		"code":    0,
		"user_id": resp.UserId,
		"token":   resp.Token,
	})
}

// 添加响应验证方法
func validateRegisterResponse(resp *user.RegisterResp) error {
	if resp.UserId <= 0 {
		return fmt.Errorf("无效的用户ID")
	}
	if len(resp.Message) == 0 {
		return fmt.Errorf("响应消息为空")
	}
	return nil
}