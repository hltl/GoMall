// Code generated by hertz generator.

package main

import (
	"context"
	"fmt"
	"net"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/hltl/GoMall/api/biz/proto/user"
	"github.com/hltl/GoMall/api/biz/router"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/app/server"
	"github.com/cloudwego/hertz/pkg/common/hlog"

	"github.com/google/uuid"
	hertzlog "github.com/hertz-contrib/logger/logrus"
	"github.com/hltl/GoMall/api/biz/database"
	"github.com/hltl/GoMall/api/biz/middleware"
	"github.com/hltl/GoMall/api/biz/proto/auth"
	"github.com/hltl/GoMall/api/biz/registry"
	"github.com/joho/godotenv"
	"github.com/sirupsen/logrus"
	"google.golang.org/grpc"
	"google.golang.org/grpc/reflection"
)

func main() {
	// 加载.env文件
	if err := godotenv.Load(); err != nil {
		logrus.WithError(err).Warn("无法加载.env文件")
	}

	// 配置日志格式和级别
	logrus.SetFormatter(&logrus.JSONFormatter{})
	logrus.SetLevel(logrus.TraceLevel)

	// 创建日志文件（新增）
	file, err := os.OpenFile("mall.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err == nil {
		logrus.SetOutput(file)
		logrus.Info("成功初始化文件日志")
	} else {
		logrus.WithError(err).Error("无法创建日志文件，请检查权限和路径")
	}

	// 初始化数据库
	db := database.InitDB()

	// 创建gRPC服务实例
	grpcServer := grpc.NewServer()

	// 注册反射服务（新增）
	reflection.Register(grpcServer)

	// 先创建UserService实例（AuthClient稍后注入）
	userServer := &router.UserServer{
		DB:         db,
		AuthClient: nil, // 暂时置空
	}
	user.RegisterUserServiceServer(grpcServer, userServer)

	// 注册AuthService
	auth.RegisterAuthServiceServer(grpcServer, &router.AuthService{})

	// 修改gRPC服务启动部分
	lis, err := net.Listen("tcp", ":50052")
	if err != nil {
		logrus.Fatalf("gRPC端口监听失败: %v", err)
	}

	// 添加启动日志
	logrus.Info("启动gRPC服务在端口50052")

	// 修改后：添加启动完成通知
	grpcStarted := make(chan struct{})
	go func() {
		logrus.Info("gRPC服务开始启动...")
		go func() {
			// 延迟1秒后发送启动完成信号
			time.Sleep(time.Second)
			close(grpcStarted)
			logrus.Info("gRPC服务启动完成")
		}()
		if err := grpcServer.Serve(lis); err != nil {
			logrus.Fatalf("gRPC服务启动失败: %v", err)
		}
	}()
	<-grpcStarted // 等待服务真正启动

	// 现在创建认证客户端（确保服务已启动）
	authClient, err := router.NewAuthClient("localhost:50052")
	if err != nil {
		logrus.WithError(err).Fatal("认证服务连接失败")
	}
	logrus.Info("认证客户端连接成功")

	// 注入AuthClient到UserService实例
	userServer.AuthClient = authClient.Service

	// 修改健康检查调用方法
	if _, err := authClient.Service.VerifyTokenByRPC(context.Background(), &auth.VerifyTokenReq{
		Token: "test",
	}); err != nil {
		logrus.WithError(err).Fatal("认证服务健康检查失败")
	}
	logrus.Info("认证服务健康检查通过")

	// 在创建authClient后添加健康检查
	if _, err := authClient.Service.HealthCheck(context.Background(), &auth.HealthCheckReq{}); err != nil {
		logrus.WithError(err).Fatal("gRPC健康检查失败")
	} else {
		logrus.Info("gRPC连接正常")
	}

	// 创建Hertz实例
	hlog.SetLogger(hertzlog.NewLogger(
		hertzlog.WithLogger(logrus.StandardLogger()),
	))
	h := server.Default(
		server.WithHostPorts(":8888"),
		server.WithExitWaitTime(5*time.Second),
	)

	// 注入userService到全局中间件
	h.Use(func(c context.Context, ctx *app.RequestContext) {
		ctx.Set("userService", userServer)
		logrus.WithFields(logrus.Fields{
			"path":   string(ctx.Path()),
			"method": string(ctx.Method()),
		}).Debug("注入userService到请求上下文")
		ctx.Next(c)
	})

	// 添加安全响应头中间件
	h.Use(func(c context.Context, ctx *app.RequestContext) {
		// 添加安全响应头
		ctx.Header("X-Content-Type-Options", "nosniff")
		ctx.Header("X-Frame-Options", "DENY")
		ctx.Header("X-XSS-Protection", "1; mode=block")
		ctx.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
		ctx.Header("Content-Security-Policy", "default-src 'self'")
		ctx.Header("Referrer-Policy", "strict-origin-when-cross-origin")

		ctx.Next(c)
	})

	// 修改 CORS 中间件
	h.Use(func(c context.Context, ctx *app.RequestContext) {
		// 获取请求的 Origin
		origin := string(ctx.Request.Header.Get("Origin"))
		if origin == "" {
			origin = "*"
		}

		// 设置 CORS 头
		ctx.Header("Access-Control-Allow-Origin", origin)
		ctx.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, PATCH, OPTIONS")
		ctx.Header("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Requested-With, X-CSRF-Token")
		ctx.Header("Access-Control-Allow-Credentials", "true")
		ctx.Header("Access-Control-Max-Age", "86400") // 24小时
		ctx.Header("Vary", "Origin")                  // 添加 Vary 头，用于缓存控制

		// 处理 OPTIONS 预检请求
		if string(ctx.Method()) == "OPTIONS" {
			logrus.WithFields(logrus.Fields{
				"path":   string(ctx.Path()),
				"method": "OPTIONS",
				"origin": origin,
			}).Debug("处理CORS预检请求")

			ctx.Status(204)
			ctx.Abort()
			return
		}

		ctx.Next(c)
	})

	// 修改 NoRoute 处理，排除 OPTIONS 请求
	h.NoRoute(func(c context.Context, ctx *app.RequestContext) {
		// 如果是 OPTIONS 请求，不作为 404 处理
		if string(ctx.Method()) == "OPTIONS" {
			ctx.Next(c)
			return
		}

		path := string(ctx.Request.URI().Path())
		method := string(ctx.Request.Method())
		logrus.WithFields(logrus.Fields{
			"path":   path,
			"method": method,
		}).Warn("请求的路径不存在")

		ctx.JSON(404, map[string]interface{}{
			"code":    404,
			"message": "请求的路径不存在",
			"path":    path,
			"method":  method,
		})
	})

	// 添加全局错误处理
	h.Use(func(c context.Context, ctx *app.RequestContext) {
		defer func() {
			if err := recover(); err != nil {
				logrus.WithFields(logrus.Fields{
					"error": err,
					"path":  string(ctx.Request.URI().Path()),
				}).Error("服务器内部错误")

				ctx.JSON(500, map[string]interface{}{
					"code":    500,
					"message": "服务器内部错误",
					"error":   fmt.Sprint(err),
				})
			}
		}()
		ctx.Next(c)
	})

	// 在其他路由注册之前添加
	h.GET("/favicon.ico", func(c context.Context, ctx *app.RequestContext) {
		logrus.Debug("请求favicon.ico")
		ctx.Status(204) // No Content
	})

	// 注册公开路由（不需要认证）
	h.POST("/register", router.UserHandlerRegister)
	h.OPTIONS("/register", func(c context.Context, ctx *app.RequestContext) {
		ctx.Status(204)
	})

	h.POST("/login", router.UserHandlerLogin)
	h.OPTIONS("/login", func(c context.Context, ctx *app.RequestContext) {
		ctx.Status(204)
	})

	h.GET("/health", func(c context.Context, ctx *app.RequestContext) {
		ctx.JSON(200, map[string]string{"status": "ok"})
	})
	h.OPTIONS("/health", func(c context.Context, ctx *app.RequestContext) {
		ctx.Status(204)
	})

	// 初始化Casbin中间件
	casbinMiddleware, err := middleware.NewCasbinMiddleware(
		"configs/rbac_model.conf",
		"configs/rbac_policy.csv",
	)
	if err != nil {
		logrus.WithError(err).Fatal("初始化Casbin中间件失败")
	}

	// 创建需要认证的路由组
	privateGroup := h.Group("/api")
	// 为私有路由组添加认证中间件
	privateGroup.Use(
		router.AuthMiddleware(authClient),
		casbinMiddleware.AuthorizeMiddleware(),
	)

	// 注册需要认证的路由
	{
		privateGroup.POST("/test", func(c context.Context, ctx *app.RequestContext) {
			panic("test panic")
		})
		// 其他需要认证的路由...
	}

	// 添加HTTP服务启动日志
	logrus.WithField("port", 8888).Info("启动HTTP服务")

	// 创建服务注册中心客户端
	etcdRegistry, err := registry.NewEtcdRegistry([]string{"localhost:2379"})
	if err != nil {
		logrus.WithError(err).Fatal("创建etcd注册中心客户端失败")
	}
	defer etcdRegistry.Close()

	// 注册服务实例
	serviceInstance := &registry.ServiceInstance{
		ID:      uuid.New().String(),
		Name:    "gomall-api",
		Address: "localhost",
		Port:    8888,
		Metadata: map[string]string{
			"version": "1.0",
		},
	}

	if err := etcdRegistry.Register(context.Background(), serviceInstance); err != nil {
		logrus.WithError(err).Fatal("服务注册失败")
	}

	// 启动HTTP服务
	go h.Spin()

	// 等待退出信号
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit

	// 优雅关闭时注销服务
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	if err := etcdRegistry.Deregister(ctx, serviceInstance); err != nil {
		logrus.WithError(err).Error("服务注销失败")
	}

	// 关闭其他连接
	grpcServer.GracefulStop()
	authClient.Close()
	sqlDB, _ := db.DB()
	sqlDB.Close()
}
